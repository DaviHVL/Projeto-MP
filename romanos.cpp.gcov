        -:    0:Source:romanos.cpp
        -:    0:Programs:2
        -:    1:#include "romanos.hpp"
        -:    2:#include <unordered_map>
        -:    3:
        -:    4:/*
        -:    5: Implementação da função para verificar
        -:    6: se há apenas algarismos romanos.
        -:    7:*/
       28:    8:bool verificador_caracteres(const string& num_romano) {
       56:    9:    const string letras = "IVXLCDM";
       99:   10:    for (char caracter : num_romano) {
       76:   11:        if (letras.find(caracter) == string::npos) {
        5:   12:            return false;
        -:   13:        }
        -:   14:    }
       23:   15:    return true;
        -:   16:}
        -:   17:
        -:   18:/*
        -:   19:Implementação da função para verificar
        -:   20:se as letras: V, L e D aparecem duas vezes seguidas.
        -:   21:*/
       23:   22:bool verificador_vld(const string& num_romano) {
       23:   23:    if (num_romano.length() == 1) {
        1:   24:        return true;
        -:   25:    }
        -:   26:
       53:   27:    if (num_romano.length() == 2  &&
       27:   28:         num_romano[0] == num_romano[1] &&
        5:   29:          num_romano[0] == 'V')  {
        1:   30:            return false;
        -:   31:    }
        -:   32:
       50:   33:    if (num_romano.length() == 2  &&
       25:   34:         num_romano[0] == num_romano[1] &&
        4:   35:          num_romano[0] == 'L')  {
        2:   36:            return false;
        -:   37:    }
        -:   38:
       44:   39:    if (num_romano.length() == 2  &&
       21:   40:         num_romano[0] == num_romano[1] &&
        2:   41:          num_romano[0] == 'D')  {
        1:   42:            return false;
        -:   43:    }
       42:   44:    for (size_t i =0; i < (num_romano.length()-2); i++) {
       37:   45:        if (num_romano[i] == num_romano[i+1] &&
       12:   46:             num_romano[i] == 'V') {
    #####:   47:            return false;
        -:   48:        }
       37:   49:        if (num_romano[i] == num_romano[i+1] &&
       12:   50:             num_romano[i] == 'L') {
        1:   51:            return false;
        -:   52:        }
       35:   53:        if (num_romano[i] == num_romano[i+1] &&
       11:   54:             num_romano[i] == 'D') {
    #####:   55:            return false;
        -:   56:        }
        -:   57:    }
       17:   58:    return true;
        -:   59:}
        -:   60:
        -:   61:/*
        -:   62:Implementação da função para verificar
        -:   63:se uma letra aparece mais de três vezes seguidas.
        -:   64:*/
       18:   65:bool verificador_mais(const string& num_romano) {
       36:   66:    unordered_map<char, int> contador;
        -:   67:
       77:   68:    for (char c : num_romano) {
       59:   69:        contador[c]++;
        -:   70:    }
        -:   71:
       46:   72:    for (const auto& par : contador) {
       33:   73:        if (par.second > 3) {
        5:   74:            return false;
        -:   75:        }
        -:   76:    }
       13:   77:    return true;
        -:   78:}
        -:   79:
        -:   80:/*
        -:   81:Função para verificar se a subtração é válida.
        -:   82:*/
       13:   83:bool verificador_subtracoes(const string& num_romano) {
        -:   84:    unordered_map<char, int>mapa_romano = {
        -:   85:        {'I', 1}, {'V', 5}, {'X', 10}, {'L', 50},
        -:   86:        {'C', 100}, {'D', 500}, {'M', 1000}
       26:   87:    };
        -:   88:
       13:   89:    int ultValor = 0;
        -:   90:
       46:   91:    for (int i = num_romano.length() - 1; i >= 0; --i) {
       35:   92:        char atualChar = num_romano[i];
       35:   93:        int atualValor = mapa_romano[atualChar];
        -:   94:
       35:   95:        if (atualValor < ultValor) {
       10:   96:            if (!((atualValor == 1 && (ultValor == 5 || ultValor == 10)) ||
        1:   97:                  (atualValor == 10 && (ultValor == 50 || ultValor == 100)) ||
    #####:   98:                  (atualValor == 100 &&
    #####:   99:                    (ultValor == 500 || ultValor == 1000)))) {
        2:  100:                return false;
        -:  101:            }
        -:  102:        }
       33:  103:        ultValor = atualValor;
        -:  104:    }
       11:  105:    return true;
        -:  106:}
        -:  107:
        -:  108:/*
        -:  109:Função principal.
        -:  110:*/
       28:  111:int romanos_para_decimal(const string& num_romano) {
       28:  112:    if (!verificador_caracteres(num_romano)) {
        5:  113:        return -1;
        -:  114:    }
       23:  115:    if (!verificador_vld(num_romano)) {
        5:  116:        return -1;
        -:  117:    }
       18:  118:    if (!verificador_mais(num_romano)) {
        5:  119:        return -1;
        -:  120:    }
        -:  121:
       13:  122:    if (!verificador_subtracoes(num_romano)) {
        2:  123:        return -1;
        -:  124:    }
        -:  125:
        -:  126:    unordered_map<char, int>mapa_romano = {
        -:  127:        {'I', 1}, {'V', 5}, {'X', 10}, {'L', 50},
        -:  128:        {'C', 100}, {'D', 500}, {'M', 1000}
       22:  129:    };
        -:  130:
       11:  131:    int result = 0;
        -:  132:
       42:  133:    for (size_t i = 0; i < (num_romano.length()); i++) {
       51:  134:        if (i+1 < num_romano.length() &&
       20:  135:             mapa_romano[num_romano[i+1]] > mapa_romano[num_romano[i]]) {
        6:  136:            result -= mapa_romano[num_romano[i]];
        -:  137:        } else {
       25:  138:            result += mapa_romano[num_romano[i]];
        -:  139:        }
        -:  140:    }
        -:  141:
       11:  142:    if (result < 0) {
    #####:  143:        return -1;
        -:  144:    } else {
       11:  145:        return result;
        -:  146:    }
        3:  147:}
